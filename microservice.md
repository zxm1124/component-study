# 微服务知识点



<img src="D:\GoModules\go-microservice\index.jpg"/>

## 微服务架构模式

- 基础设施相关模式组

  主要解决系统应用之下的基础设施有关问题，例如

  - 应用的部署
  - 服务之间的通信方式
  - 涉及服务发现的一些相关问题
  - 外部api
  - 等等...

- 应用基础设施相关模式组

  主要解决应用层面的基础设是相关问题

  - 边界问题
  - 系统的安全性
  - 事务性消息
  - 服务之间的通信风格
  - 系统的可靠性
  - 系统的可观测性

- 应用相关模式组

  主要解决系统使用架构和技术相关问题

  - 数据库架构
  - 维护数据的一致性
  - 测试



### 服务拆分的相关模式(2)

​	对于使用了微服务架构的应用而言，如何将一个单体式应用拆分成多个微服务成为一个亟待解决的问题。根据业务能力分解模式和根据子域分解模式是最为流行的两种服务拆分模式。

​	根据子域拆分模式主要是围绕领域驱动设计（DDD）来组织

### 通信的相关模式（3）

 -	通信风格：使用了哪一类进程间通信机制
 -	服务发现：客户端如何获取服务实例的ip地址
 -	可靠性：当服务不可用时，如何确保服务的可靠通信
 -	事务性消息：如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成
-	外部API：客户端如何与服务进行通信

### 实现事务管理的数据一致性相关模式（4-6）

- 两步式（2pc）提交的分布式事务机制为什么不适用于微服务架构中
- Saga模式的使用

### 查询数据的相关模式（7）

​	在单体式架构中，依靠主外键的多表查询完全可以在单个服务方法内部中实现，而在微服务架构中，服务之间是以API接口为边界，每个服务都有独立的数据库，彼此不能互相操作。因此引出了**命令查询职责隔离（CQRS）**方式

### 服务部署的相关模式（12）

​	在传统的单体式应用中，只需将应用打包成WAR文件，并复制到Tomcat服务器中。但对使用了微服务架构的应用显然不能这么做。

​	因为基于微服务架构的应用由非常多的服务构成，其中每个服务使用的语言、框架和环境等都不尽相同，因此这部分主要是学习docker容器的部署，k8s容器编排等知识

### 可观测性的相关模式（11）

​	这部分主要是监控应用的运行状态，根据应用出现的请求错误、异常或者延迟故障等进行诊断排查，主要有以下几点：

 -	健康检查：主要通过某种机制，定时对服务的api接口进行检查，检测服务能够正常运行
 -	日志聚合：把每个服务产生的日志信息写入一个集中式的日志服务器，该服务器能够提供日志搜索，也可以根据日志情况触发报警
 -	分布式链路追踪：为每一个外部请求分配一个唯一的ID，在每个服务之间进行传递
 -	异常跟踪：把程序异常发送到异常跟踪服务，并排除重复异常
 -	应用指标：记录服务器的运行参数，方便应用维护
 -	审计日志：记录用户行为

### 实现服务自动化测试的相关模式（9-10）

	-	消费端驱动的契约测试：验证服务满足客户端所期望的功能
	-	消费端契约测试：验证服务的客户端可以正常与服务通信
	-	服务组件测试：在隔离的环境中测试服务

### 解决基础设施和边界问题的相关模式

​	不需要每次构建一次底层基础配置，应该使用成熟的基础框架

### 安全相关模式

​	在微服务架构中，用户身份验证的功能通常由API Gateway完成，并将用户的有关信息（角色和身份，通常是JWT）传递给调用他的服务。



## 什么是服务

​	微服务架构和微服务是两种不同的概念，前者是一种软件架构的设计模式，后者是微服务架构系统的一部分。微服务是将一系列API封装成一个可独立部署、运行的软件，外部客户端只需要通过RESTful接口或者RPC（Remote Procedure Call）就能对服务器发起请求。

​	微服务架构最核心的特性就是服务之间的**松耦合性**。服务间以API为边界，封装了服务内部的实现细节，每个服务只维护自身的代码，当一个服务的代码出现修改或者错误时，并不影响其他服务的状态



## 服务进程间通信机制

### REST

- REST成熟度模型
  - level 0/1/2/3
- 优点和缺点
  - 优点：
    - 简单，可以使用Postman或者curl命令进行测试
    - 明文传输参数，能够清楚的看到传输数据
    - 直接支持请求/响应方式的通信
    - 不需要中间代理，简化了系统架构
  - 缺点
    - 只支持请求/响应方式的通信
    - 可用性降低，没有中间代理进行缓冲消息，在调用期间必须在线
    - 单个请求中获取多个资源具有挑战性
    - 很难将多个更新操作映射到HTTP动词
      - 例如，更新订单，修改订单，取消订单使用的都是POST操作，难以进行区分。
      - 取消：/orders/{orderId}/cancel 
      - 修改：/orders/{orderId}/revise

### gRPC

​	gRPC是一套序列化结构化数据的一套语言中立机制，使用HTTP/2以及Protocol Buffer 格式交换二进制数据，相较于XML、Json格式更加高效。

​	gRPC使用Protocol Buffers作为消息格式，是一种高效且紧凑的二进制格式，也是一种标记格式。消息当中的的每个字段都有一个编号，并且有一个类型代码。接收方可以提取所需的字段，并跳过无法识别的字段。因此能够方便再日后开发向后兼容的API

- 优点和缺点
  - 优点：
    - 设计具有复杂更新操作的API非常简单
    - 高效，尤其是在交换大量消息时
    - 支持双向流的消息传递
  - 缺点：
    - Js客户端使用gRPC的API需要做更多的工作（这个不是很了解）
    - 旧式防火墙可能不支持HTTP/2

### 服务治理：远程过程调用服务的局部故障处理

​	当服务A调用服务B时，服务B可能因为故障或维护的原因，又或者因为请求过载使的响应速度变得极其缓慢，而服务A迟迟得不到响应，产生了线程阻塞。尤其是当数以万计的请求均出现了阻塞，那么服务就会消耗过多的线程，从而导致服务出现出现故障

​	可以使用以下几个措施来保证服务的可用性

 - 网络超时

   ​	在服务被调用时，应该设置一个超时时间，而不应该设计成无限阻塞，只要服务在规定的时间没有响应，那么就中断这次请求

 - 限流

   ​	给服务端设置一个请求上限，如果请求达到了这个上限，那么就应该立即让这次请求失败

 - 熔断器

   ​	监控客户端发出请求的成功和失败数，如果失败的比例超过了一定的阈值，就启动熔断器，让后续的调用立即失败。并且在一定的时间内，服务端应该自行修复这次错误，如果下一次客户端发起请求并得到响应时，则解除熔断器

-	设置缓存

  ​	对于一些不那么重要的服务而言，当出现故障时，可以向客户端回显预先设置好的默认值或者缓存消息

### 服务发现

